{"version":3,"sources":["../src/feature.js"],"names":["Feature","extend","namespace","getFeature","keyType","key","options","reject","Error","feature","spark","device","features","get","resolve","full","serialize","value","setFeature","request","method","api","resource","userId","body","mutable","val","then","res","add","merge","setBundledFeatures","featureList","forEach","item","type","initialize","args","prototype","listenToAndRun","trigger","bind"],"mappings":"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","file":"feature.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport '@ciscospark/plugin-wdm';\nimport {SparkPlugin} from '@ciscospark/spark-core';\n\nconst Feature = SparkPlugin.extend({\n  namespace: `Feature`,\n\n  /**\n   * Returns the value of the requested feature toggle.\n   * @param {string} keyType <developer|user|entitlement>\n   * @param {string} key\n   * @param {Object} options\n   * @param {boolean} options.full to get full feature record including metadata.\n   * @returns {string|boolean|number|FeatureModel|null}\n   */\n  getFeature(keyType, key, options) {\n    if (keyType !== `developer` && keyType !== `user` && keyType !== `entitlement`) {\n      return Promise.reject(new Error(`Invalid feature keyType provided. Only \\`developer\\`, \\`user\\`, and \\`entitlement\\` feature toggles are permitted.`));\n    }\n\n    options = options || {};\n\n    const feature = this.spark.device.features[keyType].get(key);\n\n    if (!feature) {\n      return Promise.resolve(null);\n    }\n\n    if (options.full) {\n      return Promise.resolve(feature.serialize());\n    }\n\n    return Promise.resolve(feature.value);\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {string} keyType <developer|user>\n   * @param {string} key\n   * @param {string} value\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint's response.\n   */\n  setFeature(keyType, key, value) {\n    // Limit only to developer feature toggles for now.\n    if (keyType !== `developer` && keyType !== `user`) {\n      return Promise.reject(new Error(`Only \\`developer\\` and \\`user\\` feature toggles can be set.`));\n    }\n\n    return this.request({\n      method: `POST`,\n      api: `feature`,\n      resource: `features/users/${this.spark.device.userId}/${keyType}`,\n      body: {\n        key,\n        mutable: true,\n        val: value\n      }\n    })\n      .then((res) => this.spark.device.features[keyType].add(res.body, {merge: true}));\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {array} featureList\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint`s response.\n   */\n  setBundledFeatures(featureList) {\n    featureList.forEach((item) => {\n      item.mutable = item.mutable || `true`;\n      item.type = item.type || `USER`;\n    });\n\n    return this.request({\n      method: `POST`,\n      api: `feature`,\n      resource: `features/users/${this.spark.device.userId}/toggles`,\n      body: featureList\n    })\n      .then((res) => this.spark.device.features[`user`].add(res.body, {merge: true}));\n  },\n\n  initialize(...args) {\n    Reflect.apply(SparkPlugin.prototype.initialize, this, args);\n\n    this.listenToAndRun(this.spark, `change:device.features.developer`, this.trigger.bind(this, `change:developer`));\n    this.listenToAndRun(this.spark, `change:device.features.entitlement`, this.trigger.bind(this, `change:entitlement`));\n    this.listenToAndRun(this.spark, `change:device.features.user`, this.trigger.bind(this, `change:user`));\n  }\n});\n\nexport default Feature;\n"]}