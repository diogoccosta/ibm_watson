'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _dec, _dec2, _desc, _value, _obj; /**!
                                       *
                                       * Copyright (c) 2016-2017 Cisco Systems, Inc. See LICENSE file.
                                       * @private
                                       */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _pluginLocus = require('@ciscospark/plugin-locus');

var _stateParsers = require('./state-parsers');

var _boolToStatus = require('./bool-to-status');

var _boolToStatus2 = _interopRequireDefault(_boolToStatus);

var _webRtcMedia = require('./web-rtc-media');

var _webRtcMedia2 = _interopRequireDefault(_webRtcMedia);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @event ringing
 * @instance
 * @memberof Call
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} Types~Feedback
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 * @extends SparkPlugin
 */
var Call = _sparkCore.SparkPlugin.extend((_dec = (0, _common.whileInFlight)('locusJoinInFlight'), _dec2 = (0, _common.whileInFlight)('locusLeaveInFlight'), (_obj = {
  namespace: 'Phone',

  children: {
    media: _webRtcMedia2.default
  },

  session: {
    correlationId: 'string',
    /**
     * @instance
     * @memberof Call
     * @type {string}
     * @readonly
     */
    facingMode: {
      type: 'string',
      values: ['user', 'environment']
    },
    locus: 'object',
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: 'object',
    /**
     * Object URL that refers to {@link Call#localMediaStream}. Will be
     * automatically deallocated when the call ends
     * @instance
     * @memberof Call
     * @type {string}
     * @readonly
     */
    localMediaStreamUrl: 'string',

    locusJoinInFlight: {
      default: false,
      type: 'boolean'
    },
    locusLeaveInFlight: {
      default: false,
      type: 'boolean'
    },
    /**
     * Object URL that refers to {@link Call#remoteMediaStream}. Will be
     * automatically deallocated when the call ends
     * @instance
     * @memberof Call
     * @type {string}
     * @readonly
     */
    remoteMediaStreamUrl: 'string'
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && this.locus.url;
      }
    },
    isActive: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.isActive)(this.locus);
      }
    },
    activeParticipants: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.activeParticipants)(this.locus);
      }
    },
    activeParticipantsCount: {
      deps: ['activeParticipants'],
      fn: function fn() {
        return this.activeParticipants.length;
      }
    },
    joined: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joined)(this.locus);
      }
    },
    joinedOnThisDevice: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joinedOnThisDevice)(this.spark, this.locus);
      }
    },
    locusUrl: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus.url;
      }
    },
    device: {
      deps: ['locus'],
      fn: function fn() {
        var _this = this;

        return this.locus.self && (0, _find3.default)(this.locus.self.devices, function (item) {
          return item.url === _this.spark.device.url;
        });
      }
    },
    mediaConnection: {
      deps: ['device'],
      fn: function fn() {
        return this.device && this.device.mediaConnections && this.device.mediaConnections[0];
      }
    },
    mediaId: {
      deps: ['mediaConnection'],
      fn: function fn() {
        return this.mediaConnection && this.mediaConnection.mediaId;
      }
    },
    remoteAudioMuted: {
      deps: ['remote'],
      fn: function fn() {
        return (0, _stateParsers.remoteAudioMuted)(this.remote);
      }
    },
    remoteVideoMuted: {
      deps: ['remote'],
      fn: function fn() {
        return (0, _stateParsers.remoteVideoMuted)(this.remote);
      }
    },
    direction: {
      deps: ['locus'],
      fn: function fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return 'out';
        }
        return (0, _stateParsers.direction)(this.locus);
      }
    },
    from: {
      deps: ['direction', 'local', 'remote'],
      fn: function fn() {
        return this.direction === 'out' ? this.local : this.remote;
      }
    },
    to: {
      deps: ['direction', 'local', 'remote'],
      fn: function fn() {
        return this.direction === 'in' ? this.local : this.remote;
      }
    },
    local: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && this.locus.self;
      }
    },
    remote: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.remoteParticipant)(this.locus);
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: ['joinedOnThisDevice', 'local', 'remote'],
      fn: function fn() {
        if (this.joinedOnThisDevice && this.remote && (0, _stateParsers.participantIsJoined)(this.remote)) {
          return 'connected';
        }

        if (this.remote && this.local) {
          if (this.remote.state === 'LEFT' || this.local.state === 'LEFT') {
            return 'disconnected';
          }

          if (this.remote.state === 'DECLINED') {
            return 'disconnected';
          }

          if (this.remote.state === 'NOTIFIED') {
            return 'ringing';
          }
        }

        return 'initiated';
      }
    },
    /**
     * Access to the remote party’s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: ['media.remoteMediaStream'],
      fn: function fn() {
        return this.media.remoteMediaStream;
      }
    },
    receivingAudio: {
      deps: ['media.receivingAudio'],
      fn: function fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: ['media.receivingVideo'],
      fn: function fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: ['media.sendingAudio'],
      fn: function fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: ['media.sendingVideo'],
      fn: function fn() {
        return this.media.sendingVideo;
      }
    }
  },

  /**
   * Initializer
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.spark.mercury, 'event:locus', function (event) {
      return _this2._onLocusEvent(event);
    });
    this.listenTo(this.media, 'error', function (error) {
      return _this2.trigger('error', error);
    });
    this.on('disconnected', function () {
      _this2.stopListening(_this2.spark.mercury);
      _this2.off();
      URL.revokeObjectURL(_this2.localMediaStreamUrl);
      _this2.localMediaStreamUrl = undefined;
      URL.revokeObjectURL(_this2.remoteMediaStreamUrl);
      _this2.remoteMediaStreamUrl = undefined;
    });

    this.listenTo(this.media, 'negotiationneeded', (0, _debounce3.default)(function () {
      _this2.media.createOffer().then(function (offer) {
        return _this2.spark.locus.updateMedia(_this2.locus, {
          sdp: offer,
          mediaId: _this2.mediaId
        });
      }).then(function () {
        return _this2._fetchExpectedLocus();
      }).then(function (locus) {
        _this2._setLocus(locus);
        var sdp = JSON.parse(_this2.mediaConnection.remoteSdp).sdp;
        return _this2.media.acceptAnswer(sdp);
      }).catch(function (reason) {
        return _this2.emit('error', reason);
      });
    }));

    this.on('change:remoteMediaStream', function () {
      if (_this2.remoteMediaStreamUrl) {
        URL.revokeObjectURL(_this2.remoteMediaStreamUrl);
      }
      if (_this2.remoteMediaStream) {
        _this2.remoteMediaStreamUrl = URL.createObjectURL(_this2.remoteMediaStream);
      } else {
        _this2.unset('remoteMediaStreamUrl');
      }
    });

    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on('change:media.localMediaStream', function () {
      _this2.localMediaStream = _this2.media.localMediaStream;
      if (_this2.localMediaStreamUrl) {
        URL.revokeObjectURL(_this2.localMediaStreamUrl);
      }
      if (_this2.localMediaStream) {
        _this2.localMediaStreamUrl = URL.createObjectURL(_this2.localMediaStream);
      } else {
        _this2.unset('localMediaStreamUrl');
      }
    });

    this.on('change:localMediaStream', function () {
      if (_this2.media.localMediaStream !== _this2.localMediaStream) {
        _this2.media.localMediaStream = _this2.localMediaStream;
      }

      if (_this2.facingMode) {
        var mode = (0, _get3.default)(_this2, 'media.videoConstraint.facingMode.exact');
        if (mode === 'user') {
          _this2.facingMode = 'user';
        }

        if (mode === 'environment') {
          _this2.facingMode = 'environment';
        }
      }
    });

    ['remoteMediaStream', 'remoteMediaStreamUrl', 'localMediaStream', 'localMediaStreamUrl', 'remoteAudioMuted', 'remoteVideoMuted'].forEach(function (key) {
      _this2.on('change:' + key, function () {
        return _this2.trigger(key + ':change');
      });
    });

    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on('change:isActive', function () {
      if (!_this2.isActive) {
        if (_this2.joinedOnThisDevice) {
          _this2.logger.info('call: hanging up due to locus going inactive');
          _this2.hangup();
        }
      }
    });

    this.on('change:activeParticipantsCount', function () {
      var previousLocus = _this2.previousAttributes().locus;
      if (_this2.joinedOnThisDevice && _this2.activeParticipantsCount === 1 && previousLocus && (0, _stateParsers.activeParticipants)(previousLocus).length > 1) {
        _this2.logger.info('call: hanging up due to last participant in call');
        _this2.hangup();
      }
    });

    this.on('change:status', function () {
      switch (_this2.status) {
        case 'ringing':
          _this2.trigger('ringing');
          break;
        case 'connected':
          _this2.trigger('connected');
          break;
        case 'disconnected':
          _this2.trigger('disconnected');
          break;
        default:
        // do nothing
      }
    });
  },
  answer: function answer(options) {
    var _this3 = this;

    this.logger.info('call: answering');
    if (!this.locus || this.direction === 'out') {
      this.logger.info('call: outbound call, answer() is a noop');
      return _promise2.default.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    if (this.joinedOnThisDevice && this.media.peer) {
      this.logger.info('call: already joined on this device');
      return _promise2.default.resolve();
    }
    return this._join('join', this.locus, options).then((0, _common.tap)(function () {
      return _this3.logger.info('call: answered');
    }));
  },
  acknowledge: function acknowledge() {
    var _this4 = this;

    this.logger.info('call: acknowledging');
    return this.spark.locus.alert(this.locus).then(function (locus) {
      return _this4._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this4.logger.info('call: acknowledged');
    }));
  },
  dial: function dial(invitee, options) {
    var _this5 = this;

    this.locusJoinInFlight = true;
    this.logger.info('call: dialing');

    if (_common.base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      var parsed = _common.base64.decode(invitee).split('/');
      var resourceType = parsed[3];
      var id = parsed[4];
      if (resourceType === 'PEOPLE') {
        invitee = id;
      }
    }

    this.logger.info(this.registered, !!this.spark.device.url, this.connected, this.spark.mercury.connected, this.spark.device.url);

    // Note: mercury.connect() will call device.register() if need. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.mercury.connect().then(function () {
      return _this5._join('create', invitee, options);
    }).then((0, _common.tap)(function () {
      return _this5.logger.info('call: dialed');
    })).catch(function (reason) {
      _this5.trigger('error', reason);
    }).then(function () {
      _this5.locusJoinInFlight = false;
    });

    return this;
  },


  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup: function hangup() {
    var _this6 = this;

    // Note: not a @oneFlight because this function must call itself
    if (this.direction === 'in' && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info('call: hanging up');

    this.media.end();

    if (this.locusJoinInFlight) {
      this.logger.info('call: locus join in flight, waiting for rest call to complete before hanging up');
      return this.when('change:locusJoinInFlight').then(function () {
        return _this6.hangup();
      });
    }

    if (!this.locus) {
      this.stopListening(this.spark.mercury);
      this.off();
      this.logger.info('call: hang up complete, call never created');
      return _promise2.default.resolve();
    }

    return this._hangup();
  },
  _hangup: function _hangup() {
    var _this7 = this;

    return this.spark.locus.leave(this.locus).then(function (locus) {
      return _this7._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this7.stopListening(_this7.spark.mercury);
    })).then((0, _common.tap)(function () {
      return _this7.off();
    })).then((0, _common.tap)(function () {
      return _this7.logger.info('call: hung up');
    }));
  },


  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline: function decline() {
    return this.reject();
  },
  reject: function reject() {
    var _this8 = this;

    if (this.direction === 'out') {
      return _promise2.default.resolve();
    }

    this.logger.info('call: rejecting');
    /* eslint no-invalid-this: [0] */
    return this.spark.locus.decline(this.locus).then(function (locus) {
      return _this8._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this8.stopListening(_this8.spark.mercury);
    })).then((0, _common.tap)(function () {
      return _this8.off();
    })).then((0, _common.tap)(function () {
      return _this8.logger.info('call: rejected');
    }));
  },


  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @returns {undefined}
   */
  toggleFacingMode: function toggleFacingMode() {
    var _this9 = this;

    var constraints = {
      audio: (0, _assign2.default)({}, this.media.audioConstraint),
      video: this.media.videoConstraint
    };

    if (!constraints.video) {
      throw new Error('Cannot toggle facignMode on audio-only call');
    }

    if (this.facingMode !== 'user' && this.facingMode !== 'environment') {
      throw new Error('Cannot determine current facing mode; specify a new localMediaStream to change cameras');
    }

    if (constraints.video === true) {
      constraints.video = {
        facingMode: {
          exact: this.facingMode
        }
      };
    }

    if (this.facingMode === 'user') {
      (0, _set3.default)(constraints, 'video.facingMode.exact', 'environment');
    } else {
      (0, _set3.default)(constraints, 'video.facingMode.exact', 'user');
    }

    return this.spark.phone.createLocalMediaStream(constraints).then(function (stream) {
      return new _promise2.default(function (resolve) {
        _this9.media.once('answeraccepted', resolve);
        _this9.localMediaStream = stream;
      });
    }).then(function () {
      _this9.facingMode = constraints.video.facingMode.exact;
    });
  },


  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio: function startSendingAudio() {
    return this._changeSendingMedia('audio', true);
  },


  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo: function startSendingVideo() {
    return this._changeSendingMedia('video', true);
  },
  startReceivingAudio: function startReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', true);
  },
  startReceivingVideo: function startReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', true);
  },


  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio: function toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },


  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo: function toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },
  stopReceivingAudio: function stopReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', false);
  },
  stopReceivingVideo: function stopReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', false);
  },


  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio: function toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },


  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo: function toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },


  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {Types~Feedback} feedback
   * @returns {Promise}
   */
  sendFeedback: function sendFeedback(feedback) {
    return this.spark.metrics.submit('meetup_call_user_rating', feedback);
  },


  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio: function stopSendingAudio() {
    return this._changeSendingMedia('audio', false);
  },


  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo: function stopSendingVideo() {
    return this._changeSendingMedia('video', false);
  },
  _changeSendingMedia: function _changeSendingMedia(key, value) {
    var _this10 = this;

    return new _promise2.default(function (resolve) {
      _this10.once('change:sending' + (key === 'audio' ? 'Audio' : 'Video'), function () {
        return resolve(_this10._updateSendingMedia());
      });
      _this10.media.set(key, value);
    });
  },
  _updateSendingMedia: function _updateSendingMedia() {
    var _this11 = this;

    // This method should never send a new sdp; if we performed an action that
    // would cause a new sdp, the onnegotiationneeded handler should exchange
    // it. this means that for a number of scenarios, we must call update media
    // twice.
    return this.spark.locus.updateMedia(this.locus, {
      sdp: this.media.peer.localDescription.sdp,
      mediaId: this.mediaId,
      audioMuted: !this.sendingAudio,
      videoMuted: !this.sendingVideo
    }).then(function () {
      return _this11.spark.locus.get(_this11.locus);
    }).then(function (locus) {
      return _this11._setLocus(locus);
    });
  },

  // eslint-disable-next-line complexity
  _join: function _join(locusMethodName, target) {
    var _this12 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


    if (options.localMediaStream) {
      this.media.set('localMediaStream', options.localMediaStream);
    } else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              exact: this.spark.phone.defaultFacingMode
            }
          }
        };
      }
      var mode = (0, _get3.default)(options, 'constraints.video.facingMode.exact');
      if (mode === 'user' || mode === 'environment') {
        this.facingMode = mode;
      }

      var recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = (0, _defaults3.default)(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });
    }

    var mediaOptions = {};
    if (options.constraints) {
      mediaOptions.audio = options.constraints.audio;
      mediaOptions.video = options.constraints.video;
    }

    if (options.offerOptions) {
      mediaOptions.offerToReceiveAudio = options.offerOptions.offerToReceiveAudio;
      mediaOptions.offerToReceiveVideo = options.offerOptions.offerToReceiveVideo;
    }

    if (mediaOptions.offerOptions || options.constraints) {
      this.media.set(mediaOptions);
    }

    if (!target.correlationId) {
      this.correlationId = options.correlationId = _uuid2.default.v4();
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    return this.media.createOffer().then(function (offer) {
      return _this12.spark.locus[locusMethodName](target, {
        localSdp: offer,
        correlationId: _this12.correlationId
      });
    }).then(function (locus) {
      _this12._setLocus(locus);
      var answer = JSON.parse(_this12.mediaConnection.remoteSdp).sdp;
      _this12.logger.info('accepting offer');
      _this12.logger.info('peer state', _this12.media.peer && _this12.media.peer.signalingState);
      if (!_this12.media.ended) {
        return _this12.media.acceptAnswer(answer).then(function () {
          return _this12.logger.info('offer accepted');
        });
      }
      _this12.logger.info('call: already ended, not accepting answer');
      return _promise2.default.resolve();
    });
  },
  _onLocusEvent: function _onLocusEvent(event) {
    var _this13 = this;

    var device = (0, _find3.default)(event.data.locus.self.devices, function (item) {
      return item.url === _this13.spark.device.url;
    });
    if (this.locus && event.data.locus.url === this.locus.url || this.correlationId && this.correlationId === device.correlationId) {
      this.logger.info('locus event: ' + event.data.eventType);
      this._setLocus(event.data.locus);
    }
  },
  _setLocus: function _setLocus(incoming) {
    var _this14 = this;

    var current = this.locus;
    if (!current) {
      this.locus = incoming;
      return _promise2.default.resolve();
    }
    var action = this.spark.locus.compare(current, incoming);

    switch (action) {
      case _pluginLocus.USE_INCOMING:
        this.locus = incoming;
        // certain reasons for setting a locus (such as from calling
        // acknowledge())
        if (this.device) {
          this.correlationId = this.device.correlationId;
        }
        break;
      case _pluginLocus.FETCH:
        return this.spark.locus.get(current).then(function (locus) {
          return _this14._setLocus(locus);
        });
      default:
      // do nothing
    }

    return _promise2.default.resolve();
  },
  _changeReceivingMedia: function _changeReceivingMedia(key, value) {
    var _this15 = this;

    return new _promise2.default(function (resolve) {
      _this15.once('change:receiving' + (key === 'offerToReceiveAudio' ? 'Audio' : 'Video'), function () {
        return resolve();
      });
      _this15.media.set(key, value);
    });
  },
  _fetchExpectedLocus: function _fetchExpectedLocus() {
    var _this16 = this;

    return this.spark.locus.get(this.locus).then(function (locus) {
      var locusAudio = locus.self.status.audioStatus.toLowerCase();
      var mediaAudio = (0, _boolToStatus2.default)(_this16.media.audio, _this16.media.offerToReceiveAudio);
      if (locusAudio !== mediaAudio) {
        _this16.logger.warn('expected audio ' + locusAudio + ' (locus) to equal ' + mediaAudio + ' (local media)');
        throw new Error('locus.self.status.audioStatus indicates the received DTO is out of date');
      }

      var locusVideo = locus.self.status.videoStatus.toLowerCase();
      var mediaVideo = (0, _boolToStatus2.default)(_this16.media.video, _this16.media.offerToReceiveVideo);
      if (locusVideo !== mediaVideo) {
        _this16.logger.warn('expected video ' + locusVideo + ' (locus) to equal ' + mediaVideo + ' (local media)');
        throw new Error('locus.self.status.videoStatus indicates the received DTO is out of date');
      }

      return locus;
    });
  }
}, (_applyDecoratedDescriptor(_obj, 'answer', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'answer'), _obj), _applyDecoratedDescriptor(_obj, 'acknowledge', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'acknowledge'), _obj), _applyDecoratedDescriptor(_obj, 'dial', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'dial'), _obj), _applyDecoratedDescriptor(_obj, '_hangup', [_common.oneFlight, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, '_hangup'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, '_updateSendingMedia', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_updateSendingMedia'), _obj), _applyDecoratedDescriptor(_obj, '_join', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_join'), _obj), _applyDecoratedDescriptor(_obj, '_fetchExpectedLocus', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, '_fetchExpectedLocus'), _obj)), _obj)));

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

exports.default = Call;
//# sourceMappingURL=call.js.map
