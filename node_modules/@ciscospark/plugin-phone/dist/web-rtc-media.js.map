{"version":3,"sources":["../src/web-rtc-media.js"],"names":["sending","audio","start","stop","video","getRemoteMediaStatus","kind","pc","signalingState","streams","getRemoteStreams","length","res","reduce","areStreamsFlowing","stream","tracks","getTracks","filter","track","isTrackReceiving","readyState","ended","undefined","getLocalMediaStatus","getLocalStreams","isFlowing","isStreamFlowing","isFlowingForTracks","isTrackFlowing","enabled","WebRTCMedia","extend","props","default","type","audioConstraint","localMediaStream","offerToReceiveAudio","offerToReceiveVideo","peer","receivingAudio","receivingVideo","remoteMediaStream","sendingAudio","sendingVideo","videoConstraint","acceptAnswer","answer","then","set","trigger","createOffer","RTCPeerConnection","iceServers","ontrack","event","forEach","onended","e","emit","p","resolve","includes","sdp","bindNegotiationEvents","end","unset","initialize","args","prototype","mediaType","on","hasTrack","once","catch","reason","bound","onnegotiationneeded","key","value","options","attrs","k"],"mappings":"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","file":"web-rtc-media.js","sourcesContent":["import AmpState from 'ampersand-state';\n\nimport {debounce, isBoolean, isObject} from 'lodash';\n\nimport {\n  acceptAnswer,\n  addStream,\n  createOffer,\n  end,\n  ensureH264,\n  getUserMedia,\n  removeStream,\n  startSendingAudio,\n  startSendingVideo,\n  stopSendingAudio,\n  stopSendingVideo\n} from './webrtc';\n\n// at some point, this could potentially move into webrtc.js, but it gets the\n// job done for now.\nconst sending = {\n  audio: {\n    start: startSendingAudio,\n    stop: stopSendingAudio\n  },\n  video: {\n    start: startSendingVideo,\n    stop: stopSendingVideo\n  }\n};\n\n/**\n * Determines if the peer connection is receiving the specified kind of media\n * @param {string} kind audio|video\n * @param {RTCPeerConnection} pc\n * @returns {bool} true if receiving, false if not\n */\nfunction getRemoteMediaStatus(kind, pc) {\n  if (pc.signalingState === `closed`) {\n    return false;\n  }\n\n  const streams = pc.getRemoteStreams();\n\n  if (streams.length === 0) {\n    return false;\n  }\n\n  const res = streams.reduce((areStreamsFlowing, stream) => {\n    const tracks = stream.getTracks().filter((track) => track.kind === kind);\n\n    if (tracks.length === 0) {\n      return false;\n    }\n\n    return tracks.reduce((isTrackReceiving, track) => {\n      if (isTrackReceiving) {\n        return isTrackReceiving;\n      }\n\n      if (track.readyState === `ended`) {\n        return false;\n      }\n\n      if (track.ended) {\n        return false;\n      }\n\n      return true;\n    }, undefined);\n  }, undefined);\n\n  if (res) {\n    return res;\n  }\n\n  return false;\n}\n\n/**\n * Determines if the peer connection is sending the specified kind of media\n * @param {string} kind audio|video\n * @param {RTCPeerConnection} pc\n * @returns {bool} true if sending, false if not\n */\nfunction getLocalMediaStatus(kind, pc) {\n  const res = pc.getLocalStreams().reduce((isFlowing, stream) => {\n    const isStreamFlowing = stream.getTracks().reduce((isFlowingForTracks, track) => {\n      const isTrackFlowing = track.kind === kind && track.enabled;\n      return isFlowingForTracks || isTrackFlowing;\n    }, false);\n    return isFlowing || isStreamFlowing;\n  }, false);\n  return res;\n}\n\nconst WebRTCMedia = AmpState.extend({\n  props: {\n    audio: {\n      default: false,\n      type: `boolean`\n    },\n    audioConstraint: `any`,\n    ended: {\n      default: false,\n      type: `boolean`\n    },\n    localMediaStream: {\n      default: undefined,\n      type: `object`\n    },\n    offerToReceiveAudio: {\n      default: false,\n      type: `boolean`\n    },\n    offerToReceiveVideo: {\n      default: false,\n      type: `boolean`\n    },\n    peer: {\n      type: `object`\n    },\n    receivingAudio: {\n      default: false,\n      type: `boolean`\n    },\n    receivingVideo: {\n      default: false,\n      type: `boolean`\n    },\n    remoteMediaStream: {\n      default: undefined,\n      type: `object`\n    },\n    sendingAudio: {\n      default: false,\n      type: `boolean`\n    },\n    sendingVideo: {\n      default: false,\n      type: `boolean`\n    },\n    video: {\n      default: false,\n      type: `boolean`\n    },\n    videoConstraint: `any`\n  },\n\n  acceptAnswer(answer) {\n    return acceptAnswer(this.peer, answer)\n      .then(() => {\n        this.set({\n          sendingAudio: getLocalMediaStatus(`audio`, this.peer),\n          sendingVideo: getLocalMediaStatus(`video`, this.peer)\n        });\n      })\n      .then(() => this.trigger(`answeraccepted`));\n  },\n\n  createOffer() {\n    if (!this.peer) {\n      this.peer = new RTCPeerConnection({iceServers: []});\n\n      this.peer.ontrack = (event) => {\n        this.remoteMediaStream = event.streams[0];\n\n        this.remoteMediaStream.getTracks().forEach((track) => {\n          track.onended = () => {\n            try {\n              if (track.kind === `audio`) {\n                this.receivingAudio = getRemoteMediaStatus(`audio`, this.peer);\n              }\n              else {\n                this.receivingVideo = getRemoteMediaStatus(`video`, this.peer);\n              }\n            }\n            catch (e) {\n              this.emit(`error`, e);\n            }\n          };\n        });\n\n        this.receivingAudio = getRemoteMediaStatus(`audio`, this.peer);\n        this.receivingVideo = getRemoteMediaStatus(`video`, this.peer);\n      };\n    }\n\n    let p;\n    if (this.localMediaStream) {\n      p = Promise.resolve();\n    }\n    else if (this.audio || this.video) {\n      p = Promise.resolve(getUserMedia({\n        audio: this.audioConstraint,\n        video: this.videoConstraint\n      })\n        .then((stream) => {\n          this.localMediaStream = stream;\n        }));\n    }\n\n    return Promise.resolve(p)\n      .then(() => {\n        if (this.localMediaStream && !this.peer.getLocalStreams().includes(this.localMediaStream)) {\n          addStream(this.peer, this.localMediaStream);\n        }\n      })\n      .then(() => createOffer(this.peer, {\n        offerToReceiveAudio: this.offerToReceiveAudio,\n        offerToReceiveVideo: this.offerToReceiveVideo\n      }))\n      .then(ensureH264(this.video))\n      .then((sdp) => {\n        this.bindNegotiationEvents();\n        return sdp;\n      });\n  },\n\n  end() {\n    if (!this.ended) {\n      if (this.peer && this.peer.signalingState !== `closed`) {\n        end(this.peer);\n      }\n      this.unset(`localMediaStream`);\n      this.unset(`remoteMediaStream`);\n      this.ended = true;\n    }\n  },\n\n  initialize(...args) {\n    Reflect.apply(AmpState.prototype.initialize, this, args);\n\n    [\n      `audio`,\n      `video`\n    ].forEach((mediaType) => {\n      this.on(`change:${mediaType}`, () => {\n        if (!this.peer) {\n          return;\n        }\n\n        let p;\n        if (this[mediaType]) {\n          const hasTrack = this.localMediaStream\n            .getTracks()\n            // I really don't see a more readable way to implement this\n            // eslint-disable-next-line max-nested-callbacks\n            .filter((track) => track.kind === mediaType)\n            .length;\n\n          if (hasTrack) {\n            p = sending[mediaType].start(this.peer);\n          }\n          else {\n            p = new Promise((resolve) => {\n              // I really don't see a more readable way to implement this\n              // eslint-disable-next-line max-nested-callbacks\n              this.once(`negotiationneeded`, () => {\n                this.once(`answeraccepted`, resolve);\n              });\n            });\n            sending[mediaType].start(this.peer);\n          }\n        }\n        else {\n          p = sending[mediaType].stop(this.peer);\n        }\n\n        Promise.resolve(p)\n          .then(() => {\n            this[mediaType === `audio` ? `sendingAudio` : `sendingVideo`] = getLocalMediaStatus(mediaType, this.peer);\n          })\n          .catch((reason) => {\n            this.emit(`error`, reason);\n          });\n      });\n\n    });\n\n    this.on(`change:localMediaStream`, () => {\n      if (!this.peer) {\n        return;\n      }\n\n      if (this.peer.signalingState === `closed`) {\n        return;\n      }\n\n      const streams = this.peer.getLocalStreams();\n      if (!streams.includes(this.localMediaStream)) {\n        streams.forEach((stream) => {\n          removeStream(this.peer, stream);\n        });\n        addStream(this.peer, this.localMediaStream);\n\n        const sendingAudio = getLocalMediaStatus(`audio`, this.peer);\n        const sendingVideo = getLocalMediaStatus(`video`, this.peer);\n        this.set({\n          sendingAudio,\n          audio: sendingAudio,\n          sendingVideo,\n          video: sendingVideo\n        });\n      }\n    });\n  },\n\n  /**\n   * Binds events that should be bound one time only once the session has been\n   * fully negotiated\n   * @returns {undefined}\n   */\n  bindNegotiationEvents() {\n    if (this.bound) {\n      return;\n    }\n    this.bound = true;\n\n    this.peer.onnegotiationneeded = debounce(() => {\n      this.emit(`negotiationneeded`);\n    });\n\n    this.on(`change:offerToReceiveAudio`, () => {\n      this.trigger(`negotiationneeded`);\n    });\n\n    this.on(`change:offerToReceiveVideo`, () => {\n      this.trigger(`negotiationneeded`);\n    });\n  },\n\n  set(key, value, options) {\n    let attrs;\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (isObject(key) || key === null) {\n      attrs = key;\n      options = value;\n    }\n    else {\n      attrs = {};\n      attrs[key] = value;\n    }\n\n    options = options || {};\n\n    Object.keys(attrs).forEach((k) => {\n      [`audio`, `video`].forEach((mediaType) => {\n        if (k === mediaType) {\n          if (isObject(attrs[k])) {\n            attrs[`${mediaType}Constraint`] = attrs[k];\n            attrs[k] = true;\n          }\n          else if (isBoolean(attrs[k])) {\n            attrs[`${mediaType}Constraint`] = attrs[k];\n          }\n        }\n      });\n    });\n\n    Reflect.apply(AmpState.prototype.set, this, [attrs, options]);\n  }\n\n});\n\nexport default WebRTCMedia;\n"]}